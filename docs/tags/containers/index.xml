<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>containers on Djalal Harouni</title>
    <link>https://djalal.opendz.org/tags/containers/</link>
    <description>Recent content in containers on Djalal Harouni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © 2021, Djalal Harouni; all rights reserved.</copyright>
    <lastBuildDate>Thu, 30 Nov 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://djalal.opendz.org/tags/containers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modernization of Linux proc filesystem and containers security</title>
      <link>https://djalal.opendz.org/post/linux-kernel-private-proc-instances-per-pidns/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://djalal.opendz.org/post/linux-kernel-private-proc-instances-per-pidns/</guid>
      <description>
        
          &lt;p&gt;TL;DR: The Linux kernel procfs suffers from a historical design that prevents having multiple separate procfs
instances inside the same PID namespace. All the mounts are a mirror of the internal one. This blocks developement of
Linux containers, sandboxes, and other security related features.&lt;/p&gt;
&lt;p&gt;Patch solution: &lt;a href=&#34;https://kernel-hardening.openwall.narkive.com/tI859M9N/patch-rfc-v3-0-7-proc-modernize-proc-to-support-multiple-private-instances#post1&#34;&gt;PATCH RFC v3 proc: modernize proc to support multiple private instances&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Linux containers and other sandbox mechanisms want to hide processes, files and directories of procfs, other implementations want
to restrict some procfs features. To achieve this, some solutions try to mount innaccassible files over important
ones, but this process is limited by default, as procfs entries are generally dynamic, it is hard to track all files
as new features and their access are being merged. The last blocker is how procfs is handled internally.&lt;/p&gt;
&lt;p&gt;Historically, &lt;a href=&#34;https://www.kernel.org/doc/html/latest/filesystems/proc.html&#34;&gt;Linux procfs&lt;/a&gt; was always tied to pid namespaces, during pid
namespace creation we internally create a procfs mount for it. However,
this has the effect that all new procfs mounts are just a mirror of the
internal one, any change, any mount option update, any new future
introduction will propagate to all other procfs mounts that are in the
same pid namespace, which may disable any security mount related option.&lt;/p&gt;
&lt;p&gt;For a detailed description please see: &lt;a href=&#34;https://kernel-hardening.openwall.narkive.com/tI859M9N/patch-rfc-v3-0-7-proc-modernize-proc-to-support-multiple-private-instances#post1&#34;&gt;PATCH RFC v3 proc: modernize proc to support multiple private instances&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;I have been working on a patchset to improve Linux procfs internal implementation, so we can have private procfs
instances per the same PID namespace. This will improve Linux containers security in general, as it allows to clean proc
internals, and allow to support better mount options like &lt;code&gt;hidepid&lt;/code&gt; and new ones.&lt;/p&gt;
&lt;h2&gt;Update&lt;/h2&gt;
&lt;p&gt;As of April 2020 Work has been merged and now procfs supports: &lt;a href=&#34;https://www.kernel.org/doc/html/latest/filesystems/proc.html#mount-options&#34;&gt;Per procfs instance mount options: hidepid and subset&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thanks to Alexey Gladkov and other kernel developers for keeping up the work, it took +3 years to merge the patches and
have a modern proc filesystem.&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>systemd Sandbox or systemd Lightweight Containers</title>
      <link>https://djalal.opendz.org/post/systemd-sandbox-or-systemd-lightweight-containers/</link>
      <pubDate>Sun, 15 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://djalal.opendz.org/post/systemd-sandbox-or-systemd-lightweight-containers/</guid>
      <description>
        
          &lt;p&gt;Sandboxing IoT Apps using lightweight containers is an important step for Linux-IoT based devices, it allows to reduce the exposure from mis-configuration, bugs, or vulnerability exploitation.&lt;/p&gt;
&lt;div style=&#34;text-align:center&#34;&gt;
&lt;img src=&#34;https://djalal.opendz.org/img/Security-lock-life-of-pix-4291.jpg&#34;&gt;
&lt;/div&gt;
&lt;p&gt;As a simple example the BrickerBot and similar worms did not use complex 0day exploits. They used simple attack vectors like unprotected remote shells accounts and according to internet resources, lot of IoT devices were affected. The straightforward solution in this case should be a firewall solution plus a powerful sandbox mechanism for apps.&lt;/p&gt;
&lt;p&gt;While with every new &lt;a href=&#34;https://lists.freedesktop.org/archives/systemd-devel/2017-October/039589.html&#34;&gt;systemd release&lt;/a&gt; we continue to introduce new sandbox mechanisms, by default all these mechanisms are an opt-in operation, in the future we are planning to maybe add another run-time mode to make the sandbox an opt-out operation. Meanwhile, systemd manager now allows you to run your apps from an image like most other container runtimes. However, systemd does not use any standard format, since most of the container run-times that are using this schema are usually over-engineered, and some of them are abusing some Linux kernel features to hide some other misbehavior, etc. In systemd, right now we support Lightweight Containers, by using only file system Mount Namespaces to isolate and ship Apps with their dependencies, we avoid for now the container managers complexity. Network namespaces are used rarely to only block internet access for Apps by disconnecting network interfaces. We may improve network namespace usage, but only to make it easy to integrate within the &lt;strong&gt;“ip”&lt;/strong&gt; tool, that should handle all possible network cases for Embedded Linux setups.&lt;/p&gt;
&lt;h2&gt;systemd Security Sandbox features&lt;/h2&gt;
&lt;p&gt;The following lists some new systemd sandbox options:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. New File system sandbox option:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    RootImage=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Takes a path to a block device, loopback file, etc that can be mounted as the new root filesystem for your App.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Some User privileges sandbox options:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    DynamicUser=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If set to yes, allows to run your App under different User (Unix UID/GID). The UID is allocated dynamically and released when the App stops, allowing IoT devices to follow Android model where each App is executed under a different user, separating Apps and their file access permissions.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    NoNewPrivileges=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If set, ensures that the App and all its children can never gain new privileges through execve().&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Some Network sandbox options:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    PrivateNetwork=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If set to yes, will set up a new private network namespace with only loopback interface inside, disconnecting internet access.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    IPAddressDeny=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Takes an IP address prefix, all traffic from and to this address will be blocked for the App.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    IPAddressAllow=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The whitelist or permitted IP address/network mask list.&lt;/p&gt;
&lt;p&gt;To block raw packets AF_PACKET you should also use:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    RestrictAddressFamilies=~AF_PACKET (blacklisting mode).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We are working to make this more user friendly, maybe in the near feature we will add: “ACCESS_INTERNET=yes|no” alias for those options to effectively block all inet or internet operations, including constructing raw packets and binding privileged ports.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Kernel attack surface reduction:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    RestrictNamespaces=
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;    “RestrictNamespaces=yes” or “RestrictNamespaces=~user”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Restrict Access to Linux namespaces. Most IoT devices should reduce access to Linux User Namespaces since some vulnerabilities and exploits are still targeting this feature.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    ProtectKernelTunables=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Blocks tuning Kernel parameters by making /proc and related /sys files read-only.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    ProtectKernelModules=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If set, removes the CAP_SYS_MODULE capability and blocks your App from explicitly loading or unloading modules.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    SystemCallFilter=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Seccomp system call filtering feature. In systemd we have organized Linux system calls in groups inspired from Google Chromium browser. You can restrict your App by functionality by blacklisting the system calls using the &lt;strong&gt;“~”&lt;/strong&gt; before each group. As an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    “@reboot”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;will block all related reboot system calls.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    “@module”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;will block all kernel module system calls.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;    “@mount”
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;will block all file system mount and umount system calls.&lt;/p&gt;
&lt;p&gt;For more system call filtering please refer to official systemd documentation &lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=&#34;&gt;systemd.exec&lt;/a&gt; [1]. We have a pretty usable system call filtering feature, and we are actively working on improving it.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Future plans for systemd: as the systemd project continue to evolve to handle new use cases, we have to face reality: we need 1) reduce our functionality to better handle some IoT requirements, 2) integrate with software update mechanisms. On a more generic approach we have to support more user friendly features. In the past, systemd was intended to be used by experienced service developers and SysVinit experts, today the user base is more of Container and Android Apps model users. This does not mean that we have to copy those models, but we should start with a new smooth run-time model.&lt;/p&gt;
&lt;h2&gt;References:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=&#34;&gt;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
